<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CxImage: Interpolation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Interpolation</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga6">CxImage::InterpolationMethod</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#gga6w14">CxImage::IM_NEAREST_NEIGHBOUR</a> = 1, 
<a class="el" href="group___interpolation.html#gga6w4">CxImage::IM_BILINEAR</a> = 2, 
<a class="el" href="group___interpolation.html#gga6w7">CxImage::IM_BSPLINE</a> = 3, 
<a class="el" href="group___interpolation.html#gga6w2">CxImage::IM_BICUBIC</a> = 4, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#gga6w3">CxImage::IM_BICUBIC2</a> = 5, 
<a class="el" href="group___interpolation.html#gga6w12">CxImage::IM_LANCZOS</a> = 6, 
<a class="el" href="group___interpolation.html#gga6w6">CxImage::IM_BOX</a> = 7, 
<a class="el" href="group___interpolation.html#gga6w11">CxImage::IM_HERMITE</a> = 8, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#gga6w10">CxImage::IM_HAMMING</a> = 9, 
<a class="el" href="group___interpolation.html#gga6w16">CxImage::IM_SINC</a> = 10, 
<a class="el" href="group___interpolation.html#gga6w5">CxImage::IM_BLACKMAN</a> = 11, 
<a class="el" href="group___interpolation.html#gga6w1">CxImage::IM_BESSEL</a> = 12, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#gga6w9">CxImage::IM_GAUSSIAN</a> = 13, 
<a class="el" href="group___interpolation.html#gga6w15">CxImage::IM_QUADRATIC</a> = 14, 
<a class="el" href="group___interpolation.html#gga6w13">CxImage::IM_MITCHELL</a> = 15, 
<a class="el" href="group___interpolation.html#gga6w8">CxImage::IM_CATROM</a> = 16
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga5">CxImage::OverflowMethod</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#gga5w20">CxImage::OM_COLOR</a> = 1, 
<a class="el" href="group___interpolation.html#gga5w19">CxImage::OM_BACKGROUND</a> = 2, 
<a class="el" href="group___interpolation.html#gga5w23">CxImage::OM_TRANSPARENT</a> = 3, 
<a class="el" href="group___interpolation.html#gga5w24">CxImage::OM_WRAP</a> = 4, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#gga5w22">CxImage::OM_REPEAT</a> = 5, 
<a class="el" href="group___interpolation.html#gga5w21">CxImage::OM_MIRROR</a> = 6
<br>
 }</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>RGBQUAD&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga4">CxImage::GetAreaColorInterpolated</a> (float const xc, float const yc, float const w, float const h, InterpolationMethod const inMethod, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>RGBQUAD&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga3">CxImage::GetPixelColorInterpolated</a> (float x, float y, InterpolationMethod const inMethod=IM_BILINEAR, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>RGBQUAD&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga2">CxImage::GetPixelColorWithOverflow</a> (long x, long y, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga1">CxImage::OverflowCoordinates</a> (long &amp;x, long &amp;y, OverflowMethod const ofMethod)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group___interpolation.html#ga0">CxImage::OverflowCoordinates</a> (float &amp;x, float &amp;y, OverflowMethod const ofMethod)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga6" doxytag="CxImage::InterpolationMethod" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group___interpolation.html#ga6">CxImage::InterpolationMethod</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="gga6w14" doxytag="IM_NEAREST_NEIGHBOUR" ></a>IM_NEAREST_NEIGHBOUR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w4" doxytag="IM_BILINEAR" ></a>IM_BILINEAR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w7" doxytag="IM_BSPLINE" ></a>IM_BSPLINE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w2" doxytag="IM_BICUBIC" ></a>IM_BICUBIC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w3" doxytag="IM_BICUBIC2" ></a>IM_BICUBIC2</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w12" doxytag="IM_LANCZOS" ></a>IM_LANCZOS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w6" doxytag="IM_BOX" ></a>IM_BOX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w11" doxytag="IM_HERMITE" ></a>IM_HERMITE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w10" doxytag="IM_HAMMING" ></a>IM_HAMMING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w16" doxytag="IM_SINC" ></a>IM_SINC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w5" doxytag="IM_BLACKMAN" ></a>IM_BLACKMAN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w1" doxytag="IM_BESSEL" ></a>IM_BESSEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w9" doxytag="IM_GAUSSIAN" ></a>IM_GAUSSIAN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w15" doxytag="IM_QUADRATIC" ></a>IM_QUADRATIC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w13" doxytag="IM_MITCHELL" ></a>IM_MITCHELL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga6w8" doxytag="IM_CATROM" ></a>IM_CATROM</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="CxImage::OverflowMethod" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group___interpolation.html#ga5">CxImage::OverflowMethod</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="gga5w20" doxytag="OM_COLOR" ></a>OM_COLOR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga5w19" doxytag="OM_BACKGROUND" ></a>OM_BACKGROUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga5w23" doxytag="OM_TRANSPARENT" ></a>OM_TRANSPARENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga5w24" doxytag="OM_WRAP" ></a>OM_WRAP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga5w22" doxytag="OM_REPEAT" ></a>OM_REPEAT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="gga5w21" doxytag="OM_MIRROR" ></a>OM_MIRROR</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga4" doxytag="CxImage::GetAreaColorInterpolated" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RGBQUAD CxImage::GetAreaColorInterpolated           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float const&nbsp;</td>
          <td class="mdname" nowrap> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>float const&nbsp;</td>
          <td class="mdname" nowrap> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>float const&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>float const&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga6">InterpolationMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>inMethod</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga5">OverflowMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>ofMethod</em> = <code>OM_BACKGROUND</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>RGBQUAD *const&nbsp;</td>
          <td class="mdname" nowrap> <em>rplColor</em> = <code>0</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is similar to GetPixelColorInterpolated, but this method also properly handles subsampling. If you need to sample original image with interval of more than 1 pixel (as when shrinking an image), you should use this method instead of GetPixelColorInterpolated or aliasing will occur. When area width and height are both less than pixel, this method gets pixel color by interpolating color of frame center with selected (inMethod) interpolation by calling GetPixelColorInterpolated. If width and height are more than 1, method calculates color by averaging color of pixels within area. Interpolation method is not used in this case. Pixel color is interpolated by averaging instead. If only one of both is more than 1, method uses combination of interpolation and averaging. Chosen interpolation method is used, but since it is averaged later on, there is little difference between IM_BILINEAR (perhaps best for this case) and better methods. IM_NEAREST_NEIGHBOUR again leads to aliasing artifacts. This method is a bit slower than GetPixelColorInterpolated and when aliasing is not a problem, you should simply use the later.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>xc,yc</em>&nbsp;</td><td>- center of (rectangular) area </td></tr>
    <tr><td></td><td valign=top><em>w,h</em>&nbsp;</td><td>- width and height of area </td></tr>
    <tr><td></td><td valign=top><em>inMethod</em>&nbsp;</td><td>- interpolation method that is used, when interpolation is used (see above) </td></tr>
    <tr><td></td><td valign=top><em>ofMethod</em>&nbsp;</td><td>- overflow method used when retrieving individual pixel colors </td></tr>
    <tr><td></td><td valign=top><em>rplColor</em>&nbsp;</td><td>- replacement colour to use, in OM_COLOR</td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="CxImage::GetPixelColorInterpolated" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RGBQUAD CxImage::GetPixelColorInterpolated           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga6">InterpolationMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>inMethod</em> = <code>IM_BILINEAR</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga5">OverflowMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>ofMethod</em> = <code>OM_BACKGROUND</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>RGBQUAD *const&nbsp;</td>
          <td class="mdname" nowrap> <em>rplColor</em> = <code>0</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method reconstructs image according to chosen interpolation method and then returns pixel (x,y). (x,y) can lie between actual image pixels. If (x,y) lies outside of image, method returns value according to overflow method. This method is very useful for geometrical image transformations, where destination pixel can often assume color value lying between source pixels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>(x,y)</em>&nbsp;</td><td>- coordinates of pixel to return GPCI method recreates "analogue" image back from digital data, so x and y are float values and color value of point (1.1,1) will generally not be same as (1,1). Center of first pixel is at (0,0) and center of pixel right to it is (1,0). (0.5,0) is half way between these two pixels. </td></tr>
    <tr><td></td><td valign=top><em>inMethod</em>&nbsp;</td><td>- interpolation (reconstruction) method (kernel) to use:<ul>
<li>IM_NEAREST_NEIGHBOUR - returns colour of nearest lying pixel (causes stairy look of processed images)</li><li>IM_BILINEAR - interpolates colour from four neighbouring pixels (softens image a bit)</li><li>IM_BICUBIC - interpolates from 16 neighbouring pixels (can produce "halo" artifacts)</li><li>IM_BICUBIC2 - interpolates from 16 neighbouring pixels (perhaps a bit less halo artifacts than IM_BICUBIC)</li><li>IM_BSPLINE - interpolates from 16 neighbouring pixels (softens image, washes colours) (As far as I know, image should be prefiltered for this method to give good results... some other time :) ) This method uses bicubic interpolation kernel from CXImage 5.99a and older versions.</li><li>IM_LANCZOS - interpolates from 12*12 pixels (slow, ringing artifacts)</li></ul>
</td></tr>
    <tr><td></td><td valign=top><em>ofMethod</em>&nbsp;</td><td>- overflow method (see comments at GetPixelColorWithOverflow) </td></tr>
    <tr><td></td><td valign=top><em>rplColor</em>&nbsp;</td><td>- pointer to color used for out of borders pixels in OM_COLOR mode (and other modes if colour can't calculated in a specified way)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>interpolated color value (including interpolated alpha value, if image has alpha layer)</dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="CxImage::GetPixelColorWithOverflow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> RGBQUAD CxImage::GetPixelColorWithOverflow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga5">OverflowMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>ofMethod</em> = <code>OM_BACKGROUND</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>RGBQUAD *const&nbsp;</td>
          <td class="mdname" nowrap> <em>rplColor</em> = <code>0</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method return pixel color. Different methods are implemented for out of bounds pixels. If an image has alpha channel, alpha value is returned in .RGBReserved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>x,y</em>&nbsp;</td><td>: pixel coordinates </td></tr>
    <tr><td></td><td valign=top><em>ofMethod</em>&nbsp;</td><td>: out-of-bounds method:<ul>
<li>OF_WRAP - wrap over to pixels on other side of the image</li><li>OF_REPEAT - repeat last pixel on the edge</li><li>OF_COLOR - return input value of color</li><li>OF_BACKGROUND - return background color (if not set, return input color)</li><li>OF_TRANSPARENT - return transparent pixel</li></ul>
</td></tr>
    <tr><td></td><td valign=top><em>rplColor</em>&nbsp;</td><td>: input color (returned for out-of-bound coordinates in OF_COLOR mode and if other mode is not applicable)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>color : color of pixel </dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="CxImage::OverflowCoordinates" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void CxImage::OverflowCoordinates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">long &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>long &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga5">OverflowMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>ofMethod</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recalculates coordinates according to specified overflow method. If pixel (x,y) lies within image, nothing changes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>x,y</em>&nbsp;</td><td>- coordinates of pixel </td></tr>
    <tr><td></td><td valign=top><em>ofMethod</em>&nbsp;</td><td>- overflow method</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>x, y - new coordinates (pixel (x,y) now lies inside image)</dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="CxImage::OverflowCoordinates" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void CxImage::OverflowCoordinates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="group___interpolation.html#ga5">OverflowMethod</a> const&nbsp;</td>
          <td class="mdname" nowrap> <em>ofMethod</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
See OverflowCoordinates for integer version <dl compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 11 22:30:18 2004 for CxImage by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
